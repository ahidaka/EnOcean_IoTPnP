/************************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.6.9.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * Generated Date: 2020/06/07
 ***********************************************************************************************/

#include "enoceanpnptest2_sensor_interface.h"

#define MAX_MESSAGE_SIZE 256

//
// Application state associated with this interface.
// It contains the DIGITALTWIN_INTERFACE_CLIENT_HANDLE used for responses in callbacks along with properties set
// and representations of the property update and command callbacks invoked on given interface
//
typedef struct ENOCEANPNPTEST2_SENSOR_INTERFACE_STATE_TAG
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceClientHandle;

} ENOCEANPNPTEST2_SENSOR_INTERFACE_STATE;

static ENOCEANPNPTEST2_SENSOR_INTERFACE_STATE appState;

// EnOceanPnPTest2_sensorInterface_TelemetryCallback is invoked when a DigitalTwin telemetry message is either successfully delivered to the service or else fails.
static void EnOceanPnPTest2_sensorInterface_TelemetryCallback(DIGITALTWIN_CLIENT_RESULT digitalTwinTelemetryStatus, void* userContextCallback)
{
    (void)userContextCallback;
    if (digitalTwinTelemetryStatus == DIGITALTWIN_CLIENT_OK)
    {
        SendTelemetry_Succeeded_Callback("EnOceanPnPTest2_sensor");
        LogInfo("ENOCEANPNPTEST2_SENSOR_INTERFACE: DigitalTwin successfully delivered telemetry message.");
    }
    else
    {
        SendTelemetry_Error_Callback("EnOceanPnPTest2_sensor");
        LogError("ENOCEANPNPTEST2_SENSOR_INTERFACE: DigitalTwin failed to deliver telemetry message, error=<%s> ", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinTelemetryStatus));
    }
}

DIGITALTWIN_CLIENT_RESULT EnOceanPnPTest2_sensorInterface_Telemetry_SendAll()
{
    if (appState.interfaceClientHandle == NULL)
    {
        LogError("ENOCEANPNPTEST2_SENSOR_INTERFACE: interfaceClientHandle is required to be initialized before sending telemetries");
    }

    DIGITALTWIN_CLIENT_RESULT result;

    char combinedMessage[MAX_MESSAGE_SIZE];
    char telemetryValue[MAX_MESSAGE_SIZE];

    // Send multiple telemetries in a single message
    sprintf(combinedMessage, "{");

    EnOceanPnPTest2_sensor_SerializeTemperatureTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", EnOceanPnPTest2_sensorInterface_TemperatureTelemetry, telemetryValue);

    EnOceanPnPTest2_sensor_SerializeHumidityTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", EnOceanPnPTest2_sensorInterface_HumidityTelemetry, telemetryValue);

    EnOceanPnPTest2_sensor_SerializeIlluminationTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", EnOceanPnPTest2_sensorInterface_IlluminationTelemetry, telemetryValue);

    EnOceanPnPTest2_sensor_SerializeAccelerationstatusTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", EnOceanPnPTest2_sensorInterface_AccelerationstatusTelemetry, telemetryValue);

    EnOceanPnPTest2_sensor_SerializeAccelerationxTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", EnOceanPnPTest2_sensorInterface_AccelerationxTelemetry, telemetryValue);

    EnOceanPnPTest2_sensor_SerializeAccelerationyTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", EnOceanPnPTest2_sensorInterface_AccelerationyTelemetry, telemetryValue);

    EnOceanPnPTest2_sensor_SerializeAccelerationzTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s,", EnOceanPnPTest2_sensorInterface_AccelerationzTelemetry, telemetryValue);

    EnOceanPnPTest2_sensor_SerializeContactTelemetry(telemetryValue, MAX_MESSAGE_SIZE);

    sprintf(combinedMessage + strlen(combinedMessage), "\"%s\":%s", EnOceanPnPTest2_sensorInterface_ContactTelemetry, telemetryValue);

    sprintf(combinedMessage + strlen(combinedMessage), "}");

    if ((result = DigitalTwin_InterfaceClient_SendTelemetryAsync(appState.interfaceClientHandle, (unsigned char*)combinedMessage, strlen(combinedMessage),
        EnOceanPnPTest2_sensorInterface_TelemetryCallback, NULL)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("ENOCEANPNPTEST2_SENSOR_INTERFACE: DigitalTwin_InterfaceClient_SendTelemetryAsync failed for sending telemetry.");
    }

    return result;
}

// EnOceanPnPTest2_sensorInterface_InterfaceRegisteredCallback is invoked when this interface
// is successfully or unsuccessfully registered with the service, and also when the interface is deleted.
static void EnOceanPnPTest2_sensorInterface_InterfaceRegisteredCallback(DIGITALTWIN_CLIENT_RESULT dtInterfaceStatus, void* userInterfaceContext)
{
    LogInfo("EnOceanPnPTest2_sensorInterface_InterfaceRegisteredCallback with status=<%s>, userContext=<%p>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus), userInterfaceContext);
    if (dtInterfaceStatus == DIGITALTWIN_CLIENT_OK)
    {
        // Once the interface is registered, send our reported properties to the service.  
        // It *IS* safe to invoke most DigitalTwin API calls from a callback thread like this, though it 
        // is NOT safe to create/destroy/register interfaces now.
        LogInfo("ENOCEANPNPTEST2_SENSOR_INTERFACE: Interface successfully registered.");
    }
    else if (dtInterfaceStatus == DIGITALTWIN_CLIENT_ERROR_INTERFACE_UNREGISTERING)
    {
        // Once an interface is marked as unregistered, it cannot be used for any DigitalTwin SDK calls.
        LogInfo("ENOCEANPNPTEST2_SENSOR_INTERFACE: Interface received unregistering callback.");
    }
    else
    {
        LogError("ENOCEANPNPTEST2_SENSOR_INTERFACE: Interface received failed, status=<%s>.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus));
    }
}

//
// Create DigitalTwin interface client handle
//
DIGITALTWIN_INTERFACE_CLIENT_HANDLE EnOceanPnPTest2_sensorInterface_Create()
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceHandle;
    DIGITALTWIN_CLIENT_RESULT result;

    memset(&appState, 0, sizeof(ENOCEANPNPTEST2_SENSOR_INTERFACE_STATE));

    if ((result = DigitalTwin_InterfaceClient_Create(EnOceanPnPTest2_sensorInterfaceId,  EnOceanPnPTest2_sensorInterfaceInstanceName, EnOceanPnPTest2_sensorInterface_InterfaceRegisteredCallback, (void*)&appState, &interfaceHandle)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("ENOCEANPNPTEST2_SENSOR_INTERFACE: Unable to allocate interface client handle for interfaceId=<%s>, interfaceInstanceName=<%s>, error=<%s>", EnOceanPnPTest2_sensorInterfaceId, EnOceanPnPTest2_sensorInterfaceInstanceName, MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        interfaceHandle = NULL;
    }

    else
    {
        LogInfo("ENOCEANPNPTEST2_SENSOR_INTERFACE: Created DIGITALTWIN_INTERFACE_CLIENT_HANDLE successfully for interfaceId=<%s>, interfaceInstanceName=<%s>, handle=<%p>", EnOceanPnPTest2_sensorInterfaceId, EnOceanPnPTest2_sensorInterfaceInstanceName, interfaceHandle);
        appState.interfaceClientHandle = interfaceHandle;
    }

    return interfaceHandle;
}

void EnOceanPnPTest2_sensorInterface_Close(DIGITALTWIN_INTERFACE_CLIENT_HANDLE digitalTwinInterfaceClientHandle)
{
    // On shutdown, in general the first call made should be to DigitalTwin_InterfaceClient_Destroy.
    // This will block if there are any active callbacks in this interface, and then
    // mark the underlying handle such that no future callbacks shall come to it.
    DigitalTwin_InterfaceClient_Destroy(digitalTwinInterfaceClientHandle);

    // After DigitalTwin_InterfaceClient_Destroy returns, it is safe to assume
    // no more callbacks shall arrive for this interface and it is OK to free
    // resources callbacks otherwise may have needed.

}
